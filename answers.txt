1. Какой самый эффективный способ конкатенации строк?
Ответ: До версии 1.10 - bytes.Buffer.
Начиная с 1.10 - stgings.Builder.

2. Что такое интерфейсы, как они применяются в Go?
Ответ: Интерфейс - инструмент, пердставляющий абстракцию поведелния других типов. Определяют некоторый функционал, но не реализуют его

3. Чем отличаются RWMutex от Mutex?
Ответ: RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. 
Например, стандартный тип map.Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и 
.RLock() в других горутинах будут ждать, пока вы не отпустите мьютекс через .Unlock().
Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других горутинах блокируются, вызовы .RLock() спокойно проходят. Когда отпускаете мьютекс через .RUnlock(), ждущие вызовы .Lock() по-очереди могут забирать мьютекс на себя.
Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность. 

4. Чем отличаются буферизированные и не буферизированные каналы?
Ответ: Буферизированные каналы имеют ёмкость и, в отличии от небуферизированых позволяют горутинам работать с ними асинхронно, то есть горутина может отправить в буферизированный канал данные и продолжить вычисления, когда, используя небуфиризированный канал горутина бы ждала функцию, которас считала бы данные из канала.

5. Какой размер у структуры struct{}{}?
Ответ: Нулевой

6. Есть ли в Go перегрузка методов или операторов?
Ответ: Нет

7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281
Ответ: В случае вывода переменной - сортировка по возростанию по ключу. В случае перебор порядок неизвестен

8. В чем разница make и new?
Ответ: make используется только для слайсов, мап и каналов. New может использоваться для любый структуры. 
Make включает тип и размер, New только тип. Make возвращает сам тип, когда New - указатель. Make выделяет место в памяти и инициализирует,  New - только выделение памяти без инициализации.

9. Сколько существует способов задать переменную типа slice или map?
Ответ:
var slice []int // мапу аналогично
slice := int[]{} // мапу аналогично
slice := make([]int) // мапу аналогично
slice := new([]int) // выделение памяти без инициализации. Для мапы не подходит
slice := &[]int{} // выделение памяти без инициализации. Для мапы не подходит

10. Что выведет данная программа и почему?
func update(p *int) {
b := 2
p = &b
}
func main() {
var (
a = 1
p = &a
)
fmt.Println(*p)
update(p)
fmt.Println(*p)
}
Ответ:
1
1 Вторая единица, поскольку указатель локальный (передали по значению)


11. Что выведет данная программа и почему?
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
wg.Add(1)
go func(wg sync.WaitGroup, i int) {
fmt.Println(i)
wg.Done()
}(wg, i)
}
wg.Wait()
fmt.Println("exit")
}
Ответ: программа выдаст дедлок, поскольку wg передан по значению и основной поток не завершится

12. Что выведет данная программа и почему?
func main() {
n := 0
if true {
n := 1
n++
}
fmt.Println(n)
}
Ответ: программа выдаст 0, поскольку n реинициализируется внутри блока if и там она локальна.

13. Что выведет данная программа и почему?
func someAction(v []int8, b int8) {
v[0] = 100
v = append(v, b)
}
func main() {
var a = []int8{1, 2, 3, 4, 5}
someAction(a, 6)
fmt.Println(a)
}
Ответ: [100 2 3 4 5], слайс передаётся в функцию указателем на массив, который лежит в основе слайса и значениями len и cap. Cap передаётся равным 5.
В первой строчке функции идёт изменение первого элемента массива не расширяя его, поэтому пока ещё ссылаемся на тот же массив и изменения видны в основнйо функции.
Далее - добавляем в массив элемент, но из-за того, что Сap у нас равен 5 го создаёт новый массив с скопированными элементами и добавляет шестой элемент. Cap у 
этого массива будет равен 10. И из-за того, чтов мейне мы всё ещё ссылаемся на первый массив, то и добавленного элемента не будет.

14. Что выведет данная программа и почему?
func main() {
slice := []string{"a", "a"}
func(slice []string) {
slice = append(slice, "a")
slice[0] = "b"
slice[1] = "b"
fmt.Print(slice)
}(slice)
fmt.Print(slice)
}
Ответ:
[b,b,a]
[a,a] // логика аналогична предыдущему примеру
